// ------------------------------- //
// -------- Start of File -------- //
// ------------------------------- //
// ----------------------------------------------------------- // 
// C++ Source Code File Name: as2htm.cpp
// Compiler Used: MSVC, BCC32, GCC, HPUX aCC, SOLARIS CC
// Produced By: DataReel Software Development Team
// File Creation Date: 03/09/1999 
// Date Last Modified: 01/01/2009
// Copyright (c) 2001-2009 DataReel Software Development
// ----------------------------------------------------------- // 
// ------------- Program description and details ------------- // 
// ----------------------------------------------------------- // 
/*
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  
USA
  
This program is used to convert text file to HTML files.
*/
// ----------------------------------------------------------- // 
#include "gxdlcode.h"

#if defined (__USE_ANSI_CPP__) // Use the ANSI Standard C++ library
#include <iostream>
#include <fstream>
#else // Use the old iostream library by default
#include <iostream.h>
#include <fstream.h>
#endif // __USE_ANSI_CPP__

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "htmldrv.h"
#include "dfileb.h"
#include "futils.h"
#include "gxd_ver.h"

#ifdef __MSVC_DEBUG__
#include "leaktest.h"
#endif

// Version number and program name
const double AS2HTMVersionNumber = gxDatabaseVersion;

#if defined (__64_BIT_DATABASE_ENGINE__)
const char *ProgramName = "as2htm64";
#else // Use the 32-bit version by default
const char *ProgramName = "as2htm";
#endif

// Program globals
const int MAX_LEN = 1024; // Maximum length of fixed strings
char out_file[MAX_LEN];   // HTML file created from text file
int write_to_file = 0;    // Write the output to a file instead of stdout
char *open_file = 0;      // Name of text file currently opened
unsigned num_files = 0;   // Total number of files processed
int use_html_ext = 0;     // Use HTML file extension instead of .htm
int use_header = 0;       // Write document header and trailer
int use_comments = 0;     // Write comments to the HTML file

void HelpMessage(const char *program_name, const double version_number)
{
  char gxuffer[255];
  sprintf(gxuffer, "%.3f", version_number);
  GXSTD::cout << "\n";
  GXSTD::cout << program_name << " program version "
	      << gxuffer  << "\n";
  GXSTD::cout << "Usage: " << program_name << " [switches] infile.txt " 
	      << "\n"; 
  GXSTD::cout << "Switches: " << "\n";
  GXSTD::cout << "          -c = Write comments in html file." << "\n";
  GXSTD::cout << "          -f = Write output to file: infile.txt = infile.htm"
	      << "\n";
  GXSTD::cout << "          -h = Write a document header and trailer." << "\n";
  GXSTD::cout << "          -l = Use .html file extension, defaults to .htm" 
	      << "\n";
  GXSTD::cout << "\n";
  exit(0);
}

int ProcessArgs(char *arg)
{
  switch(arg[1]) {
    case 'c':
      use_comments = 1;
      break;
      
    case 'f':
      write_to_file = 1;
      break;

    case 'h':
      use_header = 1;
      break;
      
    case 'l':
      use_html_ext = 1;
      break;


    default:
      GXSTD::cerr << "\n";
      GXSTD::cerr << "Unknown switch " << arg << "\n";
      GXSTD::cerr << "Exiting..." << "\n";
      GXSTD::cerr << "\n";
      return 0;
  }
  arg[0] = '\0';
  return 1; // All command line arguments were valid
}

void ProcessTextFile(DiskFileB &infile, GXSTD::ostream &stream)
{
  char c;
  HyperText htm(stream);

  
  if(use_comments) {
    char date[255]; htm.GetSystemTime(date);
    htm << comment << "HTML file generated by: " << ProgramName << " version ";
    htm.precision(3);
    htm << AS2HTMVersionNumber << ecomment << "\n";
    htm << comment << "File Creation date: " << date << ecomment << "\n";
  }
  
  htm.Prologue(open_file);
  htm.StartBody("BGCOLOR=\"#FFFFFF\"");

  if(use_header) htm.DocHeader(open_file);
  
  htm.FONT("FACE=\"Courier New\" SIZE=3");
  htm << pre << "\n";

  while(!infile.df_EOF()) {
    if(infile.df_Get(c) != DiskFileB::df_NO_ERROR) {
      break; // Error reading from the disk file
    }
    if(c == '\r') continue; // Filter hard returns
    htm << c;
  }

  htm << "\n" << epre << efont << "\n";

  if(use_header) htm.DocTrailer();
  
  htm.Epilogue();
}

int GenOutputFileName(char *extension)
// Generate a name for the output file using the open_file
// name with the specified dot extension.
{
  int i = 0;
  for(i = 0; i < MAX_LEN; i++) out_file[i] = '\0';
  char *p = open_file;
  int len = strlen(p);
  for(i = 0; i < len && i != MAX_LEN; i++, p++) {
    if(*p == '.') break;
    out_file[i] = *p;
  }
  if((strlen(out_file) + strlen(extension)) > (MAX_LEN - 1)) return 0;
  strcat(out_file, extension); // Add the file extension (.xxx)
  return 1;
}

// Program's main thread of execution.
// ----------------------------------------------------------- 
int main(int argc,     // Number of strings in array argv.
	 char *argv[]) // Array of command-line argument 
// NOTE: None of the MSVC compilers will expand wildcard characters
// used in command-line arguments unless linked with the setargv.obj
// library. All the UNIX compliers will expand wildcard characters
// by default.
{
#ifdef __MSVC_DEBUG__
  InitLeakTest();
#endif

  // If no arguments are given print usage message to the screen 
  if(argc < 2) {
    HelpMessage(ProgramName, AS2HTMVersionNumber);
    return 0;
  }

  // Process command ling arguments and files 
  int narg;
  char *arg = argv[narg = 1];
  while (narg < argc) {
    if (arg[0] != '\0') {
      if (arg[0] == '-') { // Look for command line arguments
	if(!ProcessArgs(arg)) return 0; // Exit if argument is not valid
      }
      else { 
	if(futils_isdirectory((const char *)arg)) {
	  // Do not process directories
	  arg = argv[++narg];
	  continue;
	}
	open_file = arg; // Update the open file name pointer
	DiskFileB infile(open_file);
	if(!infile) {
	  GXSTD::cerr << "\n";
	  GXSTD::cerr << "Cannot open file: " << open_file << "\n";
	  GXSTD::cerr << "Exiting..." << "\n";
	  GXSTD::cerr << "\n";
	  return 0;
	}
	num_files++;

	// Process the test file
	if(write_to_file) {
	  if(use_html_ext)
	    GenOutputFileName(".html");
	  else
	    GenOutputFileName(".htm");
	  // Using the ostream classes allows the data to be written
	  // to a file, the stdout, or stderr.
	  GXSTD::fstream outfile(out_file, GXSTD::ios::out|GXSTD::ios::trunc);
	  if(!outfile) {
	    GXSTD::cerr << "\n";
	    GXSTD::cerr << "Cannot write to: " << out_file << "\n";
	    GXSTD::cerr << "Exiting..." << "\n";
	    GXSTD::cerr << "\n";
	    return 0;
	  }
	  ProcessTextFile(infile, outfile); // Write to file
	}
	else 
	  ProcessTextFile(infile, GXSTD::cout); // Write to stdout
      }
      arg = argv[++narg];
    }
  }
  
  if(num_files == 0) {
    GXSTD::cerr << "\n";
    GXSTD::cerr << "You must enter a file name." << "\n";
    GXSTD::cerr << "Exiting..." << "\n";
    GXSTD::cerr << "\n";
    return 0;
  }
  
  return 0;
}
// ----------------------------------------------------------- // 
// ------------------------------- //
// --------- End of File --------- //
// ------------------------------- //
